#include <libconfig.h>
#include <dirent.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdarg.h>
#include "common.h"

typedef struct FileList FileList;

struct FileList {
    char *name;
    struct FileList *prev;
};

static void free_file_list(FileList *fl) {
    while (fl != NULL) {
        FileList *prev = fl->prev;
        free(fl->name);
        free(fl);
        fl = prev;
    }
}

static FILE *err_log;
static bool systemd_invoked = false;

static char *resolve_listen(const char *hostname, const char *port) {
    char *conn = malloc(strlen(hostname) + strlen(port) + 2);
    CHECK_ALLOC(conn, "malloc")
    strcpy(conn, hostname);
    strcat(conn, ":");
    strcat(conn, port);
    return conn;
}

static int get_listen_from_conf(const char *filename, char **listen[]) {
    config_t config;
    config_setting_t *setting, *addr;
    const char *hostname, *port;
    int len = 0;

    config_init(&config);
    if (config_read_file(&config, filename) == CONFIG_FALSE) {
        if (config_error_line(&config) != 0) {
            fprintf(err_log,
                    "systemd-sslh-generator: %s%d%s\n",
                    filename,
                    config_error_line(&config),
                    config_error_text(&config));
            return -1;
        }
    } else {
        setting = config_lookup(&config, "listen");
        if (setting) {
            len = config_setting_length(setting);
            *listen = malloc(len * sizeof(**listen));
            CHECK_ALLOC(*listen, "malloc")
            for (int i = 0; i < len; i++) {
                addr = config_setting_get_elem(setting, i);
                if (!(config_setting_lookup_string(addr, "host", &hostname) && config_setting_lookup_string(addr, "port", &port))) {
                    fprintf(err_log,
                            "systemd-sslh-generator: line %d:Incomplete specification (hostname and port required)\n",
                            config_setting_source_line(addr));
                    return -1;
                } else {
                    (*listen)[i] = resolve_listen(hostname, port);
                }
            }
        }
    }
    return len;
}

static void write_socket_unit(FILE *socket, char *listen[], int num_addr, const char *cfg, const char *source) {
    fprintf(socket,
            "# Automatically generated by systemd-sslh-generator\n\n"
            "[Unit]\n"
            "Before=sslh@%s.service\n"
            "SourcePath=%s\n"
            "Documentation=man:sslh(8) man:systemd-sslh-generator(8)\n\n"
            "[Socket]\n"
            "FreeBind=true\n",
            cfg,
            source);
    for (int i = 0; i < num_addr; i++) {
        fprintf(socket, "ListenStream=%s\n", listen[i]);
    }
}

static void write_fork_unit_dropin(FILE *socket, const char *cfg) {
    fprintf(socket,
            "# Automatically generated by systemd-sslh-generator\n\n"
            "[Unit]\n"
            "Requires=sslh@%s.socket\n"
            "Conflicts=sslh-select@%s.service\n"
            "PartOf=sslh@%s.socket\n",
            cfg,
            cfg,
            cfg);
}

static void write_select_unit_dropin(FILE *socket, const char *cfg) {
    fprintf(socket,
            "# Automatically generated by systemd-sslh-generator\n\n"
            "[Unit]\n"
            "Requires=sslh@%s.socket\n"
            "Conflicts=sslh@%s.service\n"
            "PartOf=sslh@%s.socket\n",
            cfg,
            cfg,
            cfg);
}

static int gen_sslh_config(char *runtime_unit_dir) {
    int status = 0;
    const char *config_dir = "/etc/sslh/";
    char **listen;
    DIR *d = opendir(config_dir);
    FileList *fa = NULL;

    if (d) {
        struct dirent *dir;
        while ((dir = readdir(d)) != NULL) {
            if ((strcmp(dir->d_name, ".") == 0) || (strcmp(dir->d_name, "..") == 0)) {
                continue;
            }
            FileList *lfa = malloc(sizeof(FileList));
            CHECK_ALLOC(lfa, "malloc")
            lfa->name = malloc(strlen(dir->d_name) + 1);
            CHECK_ALLOC(lfa->name, "malloc")
            strcpy(lfa->name, dir->d_name);
            lfa->prev = NULL;
            if (fa) {
                lfa->prev = fa;
            }
            fa = lfa;
        }
        closedir(d);
    } else {
        fprintf(err_log,
                "systemd-sslh-generator: Configuration directory '/etc/sslh/' does not exist! No units generated.");
        //Config directory /etc/sslh/ does not exist
        return 0;
    }
    if (!fa) {
        fprintf(err_log,
                "systemd-sslh-generator: Configuration directory '/etc/sslh/' is empty! No units generated.");
        //No configuration files in /etc/sslh/
        return 0;
    }
    FileList *fa_ref = fa;
//    size_t num_listen_addresses = 0;
//    char **listen_addresses = NULL;
    //Process all config files
    do {
        char *end = strstr(fa->name, ".cfg");
        if (!end) {
            continue;
        }
        //Current sslh config name
        const size_t end_count = end - fa->name;
        char config_name[end_count + 1];
        memcpy(config_name, fa->name, end_count);
        config_name[end_count] = '\0';

        //Full path to current sslh config
        char full_path[strlen(config_dir) + strlen(fa->name) + 1];
        strcpy(full_path, config_dir);
        strcat(full_path, fa->name);
        FILE *config = fopen(full_path, "r");
        if (!config) {
            fprintf(err_log,
                    "systemd-sslh-generator: Could not open config file '%s': %s",
                    full_path,
                    strerror(errno));
            return errno;
        } else {
            fclose(config);
            int num_addr = get_listen_from_conf(full_path, &listen);
            if (num_addr <= 0) {
                fprintf(err_log,
                        "systemd-sslh-generator: sslh config '%s' contains no valid listen configurations!\n",
                        fa->name);
                status |= -1;
                continue;
            }
            FILE
                *socket_fd = stdout,
                *fork_dropin_fd = stdout,
                *select_dropin_fd = stdout;
            if (systemd_invoked) {
                const char
                    *socket_ext = ".socket",
                    *dropin_ext = ".conf",
                    *service_ext = ".service.d/",
                    *fork_unit_file = "/sslh@",
                    *select_unit_file = "/sslh-select@";

                const size_t runtime_len = strlen(runtime_unit_dir);

                //Systemd socket for the current sslh config
                size_t len = strlen(fork_unit_file) + strlen(config_name) + strlen(socket_ext);
                char socket_path[runtime_len + len + 1];
                strcpy(socket_path, runtime_unit_dir);
                strcat(socket_path, fork_unit_file);
                strcat(socket_path, config_name);
                strcat(socket_path, socket_ext);
                socket_fd = fopen(socket_path, "w");
                if (!socket_fd) {
                    fprintf(err_log,
                            "systemd-sslh-generator: Could not open '%s' to generate socket configuration: %s",
                            socket_path,
                            strerror(errno));
                    status |= errno;
                    continue;
                }

                //Systemd drop-in configuration for the base forking service sslh@%I.service
                len = strlen(fork_unit_file) + 2 * strlen(config_name) + strlen(service_ext) + strlen(dropin_ext);
                char fork_dropin_path[runtime_len + len + 1];
                strcpy(fork_dropin_path, runtime_unit_dir);
                strcat(fork_dropin_path, fork_unit_file);
                strcat(fork_dropin_path, config_name);
                strcat(fork_dropin_path, service_ext);
                strcat(fork_dropin_path, config_name);
                strcat(fork_dropin_path, dropin_ext);
                fork_dropin_fd = fopen(fork_dropin_path, "w");
                if (!fork_dropin_fd) {
                    fprintf(err_log,
                            "systemd-sslh-generator: Could not open '%s' to generate drop-in configuration: %s",
                            fork_dropin_path,
                            strerror(errno));
                    status |= errno;
                    fclose(socket_fd);
                    continue;
                }

                //Systemd drop-in configuration for the base select service sslh@%I.service
                len = strlen(select_unit_file) + 2 * strlen(config_name) + strlen(service_ext) + strlen(dropin_ext);
                char select_dropin_path[runtime_len + len + 1];
                strcpy(select_dropin_path, runtime_unit_dir);
                strcat(select_dropin_path, select_unit_file);
                strcat(select_dropin_path, config_name);
                strcat(select_dropin_path, service_ext);
                strcat(select_dropin_path, config_name);
                strcat(select_dropin_path, dropin_ext);
                select_dropin_fd = fopen(select_dropin_path, "w");
                if (!select_dropin_fd) {
                    fprintf(err_log,
                            "systemd-sslh-generator: Could not open '%s' to generate drop-in configuration: %s",
                            select_dropin_path,
                            strerror(errno));
                    status |= errno;
                    fclose(socket_fd);
                    fclose(fork_dropin_fd);
                    continue;
                }
            }
            write_socket_unit(socket_fd, listen, num_addr, config_name, full_path);
            write_fork_unit_dropin(fork_dropin_fd, config_name);
            write_select_unit_dropin(select_dropin_fd, config_name);
            if (systemd_invoked) {
                fclose(socket_fd);
                fclose(fork_dropin_fd);
                fclose(select_dropin_fd);
            }
//            if (listen_addresses) {
//                //Check for overlapping addresses
//                for (size_t i = 0; i < num_listen_addresses; i++) {
//                    for (size_t j = 0; j < num_addr; j++) {
//                        if (strcmp(*(listen_addresses + i), *(listen + j)) == 0) {
//                            fprintf(err_log, "systemd-sslh-generator: Overlapping listen addresses across sslh configurations!");
//                            return -1;
//                        }
//                    }
//                }
//            }
//            char *listen_addresses_copy[num_listen_addresses + num_addr];
//            if (listen_addresses) {
//                //Copy previous configurations' listen addresses into temp
//                memcpy(listen_addresses_copy, listen_addresses, num_listen_addresses);
//                //Free global list of listen addresses
//                free(listen_addresses);
//            }
//            //Copy listen addresses from current configuration into temp
//            memcpy(listen_addresses_copy + num_listen_addresses, listen, num_addr);
//            num_listen_addresses += num_addr;
//            listen_addresses = malloc(num_listen_addresses * sizeof(char *));
//            CHECK_ALLOC(listen_addresses, "malloc")
//            //Append all addresses to global list
//            memcpy(listen_addresses, listen_addresses_copy, num_listen_addresses);
            //Free all allocated listen strings
            for (size_t i = 0; i < num_addr; i++) {
                free(*(listen + i));
            }
        }
    } while((fa = fa->prev));
    free_file_list(fa_ref);
    return status;
}

int main(int argc, char *argv[]) {
    if (argc == 1 || argc == 4) {
        systemd_invoked = argc == 4;
        if (systemd_invoked) {
            err_log = fopen("/dev/kmsg", "w");
            if (!err_log) {
                return -1;
            }
        } else {
            err_log = stderr;
        }
        const int r = gen_sslh_config(systemd_invoked ? argv[1] : "");
        if (systemd_invoked) {
            fclose(err_log);
        }
        return r < 0 ? -1 : 0;
    } else {
        printf("This program takes three or no arguments.\n");
        return -1;
    }
}
