#include <libconfig.h>
#include <dirent.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdarg.h>
#include "common.h"

typedef struct FileList FileList;

struct FileList {
    char *name;
    struct FileList *prev;
};

static void free_file_list(FileList *fl) {
    while (fl != NULL) {
        FileList *prev = fl->prev;
        free(fl->name);
        free(fl);
        fl = prev;
    }
}

static char *resolve_listen(const char *hostname, const char *port) {
    char *conn = malloc(strlen(hostname) + strlen(port) + 2);
    CHECK_ALLOC(conn, "malloc")
    strcpy(conn, hostname);
    strcat(conn, ":");
    strcat(conn, port);
    return conn;
}

static int get_listen_from_conf(const char *filename, char **listen[]) {
    config_t config;
    config_setting_t *setting, *addr;
    const char *hostname, *port;
    int len = 0;

    config_init(&config);
    if (config_read_file(&config, filename) == CONFIG_FALSE) {
        if (config_error_line(&config) != 0) {
            fprintf(stderr,
                    "%s%d%s\n",
                    filename,
                    config_error_line(&config),
                    config_error_text(&config));
            return -1;
        }
    } else {
        setting = config_lookup(&config, "listen");
        if (setting) {
            len = config_setting_length(setting);
            *listen = malloc(len * sizeof(**listen));
            CHECK_ALLOC(*listen, "malloc")
            for (int i = 0; i < len; i++) {
                addr = config_setting_get_elem(setting, i);
                if (!(config_setting_lookup_string(addr, "host", &hostname) && config_setting_lookup_string(addr, "port", &port))) {
                    fprintf(stderr,
                            "line %d:Incomplete specification (hostname and port required)\n",
                            config_setting_source_line(addr)
                            );
                    return -1;
                } else {
                    (*listen)[i] = resolve_listen(hostname, port);
                }
            }
        }
    }
    return len;
}

static int write_socket_unit(FILE *socket, char *listen[], int num_addr, const char *cfg, const char *source) {
    fprintf(socket,
            "# Automatically generated by systemd-sslh-generator\n\n"
            "[Unit]\n"
            "Before=sslh@%s.service\n"
            "SourcePath=%s\n"
            "Documentation=man:sslh(8) man:systemd-sslh-generator(8)\n\n"
            "[Socket]\n"
            "FreeBind=true\n",
            cfg,
            source);
    for (int i = 0; i < num_addr; i++) {
        fprintf(socket, "ListenStream=%s\n", listen[i]);
    }
    return 0;
}

static int gen_sslh_config(char *runtime_unit_dir) {
    const bool systemd_invoked = runtime_unit_dir && *runtime_unit_dir;
    int status = 0;
    const char *unit_file = "/sslh@", *config_dir = "/etc/sslh/";
    char **listen;
    DIR *d = opendir(config_dir);
    FileList *fa = NULL;

    if (d) {
        struct dirent *dir;
        while ((dir = readdir(d)) != NULL) {
            if ((strcmp(dir->d_name, ".") == 0) || (strcmp(dir->d_name, "..") == 0)) {
                continue;
            }
            FileList *lfa = malloc(sizeof(FileList));
            CHECK_ALLOC(lfa, "malloc")
            lfa->name = malloc(strlen(dir->d_name) + 1);
            CHECK_ALLOC(lfa->name, "malloc")
            strcpy(lfa->name, dir->d_name);
            lfa->prev = NULL;
            if (fa) {
                lfa->prev = fa;
            }
            fa = lfa;
        }
        closedir(d);
    } else {
        //Config directory /etc/sslh/ does not exist
        return 0;
    }
    if (!fa) {
        //No configuration files in /etc/sslh/
        return 0;
    }
    FileList *fa_ref = fa;
//    size_t num_listen_addresses = 0;
//    char **listen_addresses = NULL;
    //Process all config files
    do {
        char *end = strstr(fa->name, ".cfg");
        if (!end) {
            continue;
        }
        const size_t end_count = end - fa->name;
        char socket_config_name[end_count + 1];
        memcpy(socket_config_name, fa->name, end_count);
        socket_config_name[end_count] = '\0';
        const size_t full_path_len = strlen(config_dir) + strlen(fa->name) + 1;
        char full_path[full_path_len];
        strcpy(full_path, config_dir);
        strcat(full_path, fa->name);
        FILE *config = fopen(full_path, "r");
        if (!config) {
            const char *error_fmt = "Could not open config file '%s':";
            const size_t error_msg_len = strlen(error_fmt) + full_path_len;
            char error_msg[error_msg_len];
            snprintf(error_msg, error_msg_len, error_fmt, full_path);
            perror(error_msg);
            return -1;
        } else {
            fclose(config);
            int num_addr = get_listen_from_conf(full_path, &listen);
            if (num_addr < 0) {
                fprintf(stderr,
                        "sslh config: '%s' contains no valid listen configurations!\n",
                        fa->name);
                status |= -1;
                continue;
            }
            FILE *runtime_conf_fd = stdout;
            if (systemd_invoked) {
                const char *unit_file_ext = ".socket";
                size_t ufp_len = strlen(unit_file) + strlen(socket_config_name) + strlen(unit_file_ext);
                char unit_file_path[ufp_len + 1];
                strcpy(unit_file_path, unit_file);
                strcat(unit_file_path, socket_config_name);
                strcat(unit_file_path, unit_file_ext);
                size_t runtime_len = strlen(runtime_unit_dir) + ufp_len + 1;
                char runtime_conf[runtime_len];
                strcpy(runtime_conf, runtime_unit_dir);
                strcat(runtime_conf, unit_file_path);
                runtime_conf_fd = fopen(runtime_conf, "w");
                if (!runtime_conf_fd) {
                    const char *error_fmt = "Could not open '%s' to generate socket configuration:";
                    const size_t error_msg_len = strlen(error_fmt) + runtime_len;
                    char error_msg[error_msg_len];
                    snprintf(error_msg, error_msg_len, error_fmt, runtime_conf);
                    perror(error_msg);
                    status |= -1;
                    continue;
                }
            }
            status |= write_socket_unit(runtime_conf_fd, listen, num_addr, socket_config_name, full_path);
            if (systemd_invoked) {
                fclose(runtime_conf_fd);
            }
//            if (listen_addresses) {
//                //Check for overlapping addresses
//                for (size_t i = 0; i < num_listen_addresses; i++) {
//                    for (size_t j = 0; j < num_addr; j++) {
//                        if (strcmp(*(listen_addresses + i), *(listen + j)) == 0) {
//                            fprintf(stderr, "Overlapping listen addresses across sslh configurations!");
//                            return -1;
//                        }
//                    }
//                }
//            }
//            char *listen_addresses_copy[num_listen_addresses + num_addr];
//            if (listen_addresses) {
//                //Copy previous configurations' listen addresses into temp
//                memcpy(listen_addresses_copy, listen_addresses, num_listen_addresses);
//                //Free global list of listen addresses
//                free(listen_addresses);
//            }
//            //Copy listen addresses from current configuration into temp
//            memcpy(listen_addresses_copy + num_listen_addresses, listen, num_addr);
//            num_listen_addresses += num_addr;
//            listen_addresses = malloc(num_listen_addresses * sizeof(char *));
//            CHECK_ALLOC(listen_addresses, "malloc")
//            //Append all addresses to global list
//            memcpy(listen_addresses, listen_addresses_copy, num_listen_addresses);
            //Free all allocated listen strings
            for (size_t i = 0; i < num_addr; i++) {
                free(*(listen + i));
            }
        }
    } while((fa = fa->prev));
    free_file_list(fa_ref);
    return status;
}

int main(int argc, char *argv[]) {
    if (argc == 1 || argc == 4) {
        return gen_sslh_config(argc == 1 ? "" : argv[1]) < 0 ? -1 : 0;
    } else {
        printf("This program takes three or no arguments.\n");
        return -1;
    }
}